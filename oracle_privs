#!/usr/bin/python
# -*- coding: utf-8 -*-

DOCUMENTATION = '''
---
module: oracle_privs
short_description: Manage object and system privileges in Oracle database
description:
    - Manage users/schemas in an Oracle database
    - Can be run locally on the controlmachine or on a remote host
version_added: "2.2.1"
options:
notes:
    - cx_Oracle needs to be installed
    - Oracle RDBMS 11g2R or later required
requirements: [ "cx_Oracle", "re" ]
author: Ilmar Kerm, ilmar.kerm@gmail.com, @ilmarkerm
'''

EXAMPLES = '''
'''

import re

try:
    import cx_Oracle
except ImportError:
    cx_oracle_exists = False
else:
    cx_oracle_exists = True

# Helper code
oraclepattern = None

def quote_string(s):
    # This function should uppercase and clean all strings sent as identifiers to Oracle
    # raise exception if string cannot be cleaned
    global oraclepattern
#    supper = s.upper()
    if oraclepattern is None:
        oraclepattern = re.compile('^[A-Z]+[A-Z0-9_]*[A-Z0-9]+$')
    if (len(s) > 32) or not oraclepattern.match(s):
        raise
    return "\"%s\"" % s

def parse_objects(objs):
    parsed_list = []
    for o in objs:
        if o.count(".") != 1 or len(o) < 3:
            module.fail_json(msg="Invalid object name %s. Object name must be in form SCHEMANAME.OBJECTNAME." % o)
        parsed_list.extend(o.split("."))
    return parsed_list

# Ansible code
def main():
    global lconn, conn, lparam, module
    msg = ['']
    module = AnsibleModule(
        argument_spec = dict(
            hostname      = dict(default='localhost'),
            port          = dict(default=1521, type='int'),
            service_name  = dict(required=True),
            user          = dict(required=True),
            password      = dict(required=True),
            mode          = dict(default='normal', choices=["normal","sysdba"]),
            state         = dict(default="present", choices=["present", "absent"]),
            privs         = dict(required=True, type='list', aliases=['priv']),
            objs          = dict(required=False, type='list', aliases=['obj']), # CASE SENSITIVE! Can use wildcard %
            roles         = dict(required=True, type='list', aliases=['role']),
        ),
        supports_check_mode=True
    )
    # Check for required modules
    if not cx_oracle_exists:
        module.fail_json(msg="The cx_Oracle module is required. 'pip install cx_Oracle' should do the trick. If cx_Oracle is installed, make sure ORACLE_HOME & LD_LIBRARY_PATH is set")
    # Check input parameters
    re_priv = re.compile('^[A-Za-z]+[A-Za-z ]*[A-Za-z]+$')
    re_role = re.compile('^[A-Za-z0-9_\$#\- ]+$')
    re_obj = re.compile('^[A-Za-z0-9_\$#\- ]*\.[A-Za-z0-9_\$#\%\- ]+$')
    for p in module.params['privs']:
        if not re_priv.match(p):
            module.fail_json(msg="Invalid privilege '%s'" % p)
    for p in module.params['roles']:
        if not re_role.match(p) or p.upper() in ['SYS','SYSTEM']:
            module.fail_json(msg="Invalid user/role '%s'" % p)
    if module.params['objs'] is not None:
        for p in module.params['objs']:
            if not re_obj.match(p):
                module.fail_json(msg="Invalid object '%s'" % p)
    # Connect to database
    dsn = cx_Oracle.makedsn(host=module.params['hostname'], port=module.params['port'], service_name=module.params['service_name'])
    try:
        if module.params['mode'] == 'sysdba':
            conn = cx_Oracle.connect(module.params['user'], module.params['password'], dsn, mode=cx_Oracle.SYSDBA)
        else:
            conn = cx_Oracle.connect(module.params['user'], module.params['password'], dsn)
    except cx_Oracle.DatabaseError, exc:
        error, = exc.args
        msg[0] = 'Could not connect to database - %s ' % (error.message)
        module.fail_json(msg=msg[0], changed=False)
    if conn.version < "11.2":
        module.fail_json(msg="Database version must be 11gR2 or greater", changed=False)
    #
    if module.check_mode:
        module.exit_json(changed=False)
    #
    c = conn.cursor()
    var_changes = c.var(cx_Oracle.NUMBER)
    var_error = c.var(cx_Oracle.NUMBER)
    var_errstr = c.var(cx_Oracle.STRING)
    var_privs = c.arrayvar(cx_Oracle.STRING, [p.upper() for p in module.params['privs']])
    var_objs = c.arrayvar(cx_Oracle.STRING, [p.replace("_", "\_") for p in module.params['objs']] if module.params['objs'] is not None else [], 100)
    var_roles = c.arrayvar(cx_Oracle.STRING, module.params['roles'], 50)
    c.execute("""
    DECLARE
        TYPE str_array IS TABLE OF VARCHAR2(50) INDEX BY BINARY_INTEGER;
        -- output
        v_changes NUMBER:= 0;
        v_error NUMBER:= 0;
        v_errstr VARCHAR2(4000);
        -- input
        v_state VARCHAR2(10);
        v_objects str_array;
        v_privs str_array;
        v_roles str_array;
        v_report_error NUMBER:= 1;
        v_privs_sql sys.DBMS_DEBUG_VC2COLL:= sys.DBMS_DEBUG_VC2COLL();
        --v_roles_sql_tmp sys.DBMS_DEBUG_VC2COLL:= sys.DBMS_DEBUG_VC2COLL();
        v_roles_sql sys.DBMS_DEBUG_VC2COLL:= sys.DBMS_DEBUG_VC2COLL();
        v_objs_sql sys.DBMS_DEBUG_VC2COLL:= sys.DBMS_DEBUG_VC2COLL();

        PROCEDURE execsql(p_sql VARCHAR2) IS
        BEGIN
            EXECUTE IMMEDIATE p_sql;
            v_changes:= v_changes+1;
            v_errstr:= v_errstr||'-'||p_sql;
        EXCEPTION
            WHEN others THEN
                v_error:= v_report_error;
                v_errstr:= v_errstr||'-"'||p_sql||'"-'||sqlerrm;
                raise;
        END;

    BEGIN
        -- assign input
        v_state:= :var_state;
        v_objects:= :var_objs;
        v_privs:= :var_privs;
        v_roles:= :var_roles;
        -- Copy to a new array that can be used in SQL
        FOR i IN v_privs.FIRST..v_privs.LAST LOOP
            v_privs_sql.extend();
            v_privs_sql(v_privs_sql.count):= v_privs(i);
        END LOOP;
        v_privs.delete;
        FOR i IN v_roles.FIRST..v_roles.LAST LOOP
            v_roles_sql.extend();
            v_roles_sql(v_roles_sql.count):= v_roles(i);
        END LOOP;
        v_roles.delete;
        /*FOR rec IN (SELECT column_value FROM table(v_roles_sql_tmp) INTERSECT (SELECT username FROM dba_users WHERE oracle_maintained='N' UNION ALL SELECT role FROM dba_roles WHERE oracle_maintained='N')) LOOP
            v_roles_sql.extend();
            v_roles_sql(v_roles_sql.count):= rec.column_value;
        END LOOP;
        v_roles_sql_tmp.delete;*/
        IF v_objects.COUNT > 0 THEN
            FOR i IN v_objects.FIRST..v_objects.LAST LOOP
                v_objs_sql.extend();
                v_objs_sql(v_objs_sql.count):= v_objects(i);
            END LOOP;
            v_objects.delete;
        END IF;
        --
        BEGIN
            IF v_objs_sql.COUNT > 0 THEN
                -- Object privileges
                IF v_state = 'present' THEN
                    FOR rec IN (
                        WITH objs AS (SELECT o.owner, o.object_name FROM dba_objects o JOIN table(v_objs_sql) s ON o.owner||'.'||o.object_name LIKE s.column_value ESCAPE '\\' WHERE o.object_type IN ('TABLE','VIEW')),
                             rp AS (SELECT r.column_value role, p.column_value priv FROM table(v_roles_sql) r CROSS JOIN table(v_privs_sql) p),
                             objpr AS (SELECT o.owner, o.object_name, rp.priv, rp.role FROM objs o CROSS JOIN rp)
                        SELECT owner, object_name, role, LISTAGG(priv,',') WITHIN GROUP (ORDER BY priv) privs FROM (
                            SELECT owner, object_name, priv, role FROM objpr
                            MINUS
                            SELECT owner, table_name, privilege, grantee FROM dba_tab_privs)
                        GROUP BY owner, object_name, role
                    ) LOOP
                        execsql('GRANT '||rec.privs||' ON "'||rec.owner||'"."'||rec.object_name||'" TO "'||rec.role||'"');
                    END LOOP;
                ELSIF v_state = 'absent' THEN
                    FOR rec IN (
                        WITH objs AS (SELECT o.owner, o.object_name FROM dba_objects o JOIN table(v_objs_sql) s ON o.owner||'.'||o.object_name LIKE s.column_value),
                             rp AS (SELECT r.column_value role, p.column_value priv FROM table(v_roles_sql) r CROSS JOIN table(v_privs_sql) p),
                             objpr AS (SELECT o.owner, o.object_name, rp.priv, rp.role FROM objs o CROSS JOIN rp)
                        SELECT t.owner, t.table_name, t.grantee, LISTAGG(t.privilege,',') WITHIN GROUP (ORDER BY t.privilege) privs
                        FROM dba_tab_privs t JOIN objpr o ON t.owner=o.owner AND t.table_name=o.object_name AND t.privilege=o.priv AND t.grantee=o.role
                        GROUP BY t.owner, t.table_name, t.grantee
                    ) LOOP
                        execsql('REVOKE '||rec.privs||' ON "'||rec.owner||'"."'||rec.table_name||'" FROM "'||rec.grantee||'"');
                    END LOOP;
                END IF;
            ELSE
                -- System/role grants
                IF v_state = 'present' THEN
--                v_errstr:= v_state;
                    FOR rec IN (
                        WITH rp AS (
                            SELECT r.role, p.column_value priv FROM (
                                SELECT r.column_value role
                                FROM table(v_roles_sql) r
                            ) r CROSS JOIN table(v_privs_sql) p)
                        SELECT role, LISTAGG(priv, ',') WITHIN GROUP (ORDER BY priv) privs FROM (
                            SELECT rp.role, rp.priv FROM rp
                            MINUS
                            SELECT grantee, privilege FROM dba_sys_privs
                            MINUS
                            SELECT grantee, granted_role FROM dba_role_privs)
                        GROUP BY role
                    ) LOOP
                        execsql('GRANT '||rec.privs||' TO "'||rec.role||'"');
                    END LOOP;
                ELSIF v_state = 'absent' THEN
                    FOR rec IN (
                        WITH rp AS (SELECT r.column_value role, p.column_value priv FROM table(v_roles_sql) r CROSS JOIN table(v_privs_sql) p)
                        SELECT s.role, LISTAGG(s.priv, ',') WITHIN GROUP (ORDER BY s.priv) privs FROM
                            (SELECT grantee role, privilege priv FROM dba_sys_privs
                             UNION ALL
                             SELECT grantee, granted_role FROM dba_role_privs) s JOIN rp ON rp.role = s.role AND rp.priv = s.priv
                        GROUP BY s.role
                    ) LOOP
                        execsql('REVOKE '||rec.privs||' FROM "'||rec.role||'"');
                    END LOOP;
                END IF;
            END IF;
        /*EXCEPTION
            WHEN others THEN
                NULL;*/
        END;
        -- assign output
        :var_error:= v_error;
        :var_errstr:= v_errstr;
        :var_changes:= v_changes;
    END;
    """, {
        'var_changes': var_changes,
        'var_error': var_error,
        'var_errstr': var_errstr,
        'var_privs': var_privs,
        'var_objs': var_objs,
        'var_roles': var_roles,
        'var_state': module.params['state']
    })
    if var_error.getvalue() > 0:
        conn.rollback()
        module.fail_json(msg=var_errstr.getvalue(), changed=var_changes.getvalue()>0)
    else:
        conn.commit()
    module.exit_json(msg=var_errstr.getvalue(), changed=var_changes.getvalue()>0)


from ansible.module_utils.basic import *
if __name__ == '__main__':
    main()
